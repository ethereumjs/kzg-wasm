import { describe, it, assert, beforeAll } from 'vitest'
import { loadKZG } from '../src/index.js'
import { bytesToHex, hexToBytes } from '../src/util.js'

const BYTES_PER_FIELD_ELEMENT = 32
const FIELD_ELEMENTS_PER_BLOB = 4096
const BYTES_PER_BLOB = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB
const CELLS_PER_EXT_BLOB = 128
const BYTES_PER_CELL = 2048
const BYTES_PER_G1 = 48

describe('kzg initialization', () => {
  let kzg: any
  beforeAll(async () => {
    kzg = await loadKZG()
  })

  it('should initialize', async () => {
    assert.typeOf(kzg.computeBlobKZGProof, 'function', 'initialized KZG object')
    kzg.freeTrustedSetup()
  })

  it('should throw when invalid trusted setup is provided', () => {
    assert.throws(() => {
      kzg.loadTrustedSetup({ g1_monomial: 'x12',  g1_lagrange: 'bad coordinates', g2_monomial: 'x12'})
    })
  })
})

describe('kzg API tests', () => {
  let kzg: Awaited<ReturnType<typeof loadKZG>>
  beforeAll(async () => {
    kzg = await loadKZG()
    const result = kzg.loadTrustedSetup()
    assert.equal(result, 0, 'loaded trusted setup successfully')
  })

  it('should generate kzg commitments and verify proofs', async () => {
    const blob = new Uint8Array(BYTES_PER_BLOB)
    blob[0] = 0x01
    blob[1] = 0x02
    const commitment = kzg.blobToKZGCommitment(bytesToHex(blob))
    assert.equal(commitment.slice(2).toLowerCase(), 'ab87358a111c3cd9da8aadf4b414e9f6be5ac83d923fb70d8d27fef1e2690b4cad015b23b8c058881da78a05c62b1173')
    const proof = kzg.computeBlobKZGProof(bytesToHex(blob), (commitment))
    assert.equal(proof.toLowerCase(), '0x8dd951edb4e0df1779c29d28b835a2cc8b26ebf69a38d7d9afadd0eb8a4cbffd9db1025fd253e91e00a9904f109e81e3')
    const proofVerified = kzg.verifyBlobKZGProofBatch([bytesToHex(blob)], [(commitment)], [proof])
    assert.equal(proofVerified, true)
  })

  it('should verify kzg proofs with points', async () => {
    const precompileData = {
      Proof: (
        '0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      ),
      Commitment: (
        '0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      ),
      z: (
        '0x623ce31cf9759a5c8daf3a357992f9f3dd7f9339d8998bc8e68373e54f00b75e'
      ),
      y: (
        '0x0000000000000000000000000000000000000000000000000000000000000000'
      ),
    }

    const verifiedKZGProof = kzg.verifyKZGProof(precompileData.Commitment, precompileData.z, precompileData.y, precompileData.Proof)
    assert.equal(verifiedKZGProof, true)
  })

  it('should calculate cells and kzg proofs', async () => {
    // Create a simple test blob with valid field elements
    const blob = new Uint8Array(BYTES_PER_BLOB)
    blob[0] = 0x01
    blob[1] = 0x02
    const blobHex = bytesToHex(blob)

    // Compute cells and proofs for the blob
    const cellsAndProofsHex = kzg.computeCellsAndKZGProofs(blobHex)

    assert(cellsAndProofsHex.proofs.length == CELLS_PER_EXT_BLOB)
    assert.equal(cellsAndProofsHex.proofs[0], "0x81D4F75E60CD7628B00D09E3E5D0F4A64111E76D090106AB49451A796E1BEDF59950080C36E24C759CF929EC59FC0E11")
    assert.equal(cellsAndProofsHex.proofs[65], "0x80FD7A0642F75A01B0813527BDACE1B8F7492C4A31A840F0C6DD2ECE0FFD6CDF9ED1C132523D5AC07C4AFB5C39E63AFB")
    assert.equal(cellsAndProofsHex.proofs[127], "0x96E54B5676BA75BC183D4DCD7C6A2A4EEE99BF71D3A44A840B854F28167C3A8D7A07AC7E9F11E6DD4A2E9B1F646632A9")
    assert(cellsAndProofsHex.cells.length == CELLS_PER_EXT_BLOB)
    assert(cellsAndProofsHex.cells[0].length == 2 + (BYTES_PER_CELL * 2))

    cellsAndProofsHex.cells.forEach((cellHex, index) => {
      if(index === 0) {
        assert(cellHex.startsWith("0x0102000000000000000000"))
      }else if (index < 64){
        for(let i = 2; i < cellHex.length; i++) {
          assert(cellHex[i] === '0', `Cell ${index} has non-zero byte at position ${i}`)
        }
      }
    })
    assert.equal(cellsAndProofsHex.cells[64], "0x68A294428F9616D968499A040830A90983C0C0640AD70799D1C9686FA1147CF920EA79CCCB2AE2A3DAF767153859CF2606279C0FD102DA0F7683032125111DB159BEBA92BA35FA9E047ED3EDAE7B8ADB9FFCD272B8DEED14BFA245B55F2027D86879C5A5A579675E059135BDF8E7780A8FAB5FC2AA8775232709AB516D7BC1A75614D701BEC85F97F9CD53C0BBB087F0950897AE9A18E47CD20F8819ED185E6428E04FA206E37DCC22A1727A0CD9C88A56B3C83605DD8523BA4A73162BBDF2190931A48B3ABE2B6A2552AA2BB4AE930A19DF24BAA8EE5A6AD5970977C6885365395D885C70A246E511CB791141205FC86989C445034712EBA667C82E88AEE1A429A83655758DEA1BDADA5261899450570C17B6C2A470D9A7B0D777FBC98F46794E74080E79217767413E33C88E5F5B0D673F06FE6F109FEAE52BC1D0278EBFD45906CD9F3802F7B42A4260625868DA7291F76F05CE3F07E6C03C5A92C9990AF52CCE39BAD9B08021E9D1B8A9EF17C38DAEAF4912BF80CE72E1162219C16F733154E0FCC3AD39D833475CB44B42F69E398A0AAB09C0854C27BE849B9237534E172F61500F77CC8AC03721B1CA9E2AA70618F501A65059749920F5D65C5C1418D2148DA197DBECFA31027FD0898C9E9A8FEDC159BF11F5D8CEAE62B561332B05C2424BF6A6FFC7903E5480FBE6D5F60DE326E09C7628B49B53901C7CDA371EC70F12F23116D27CE227D1EE5684BD45B670CD950BFF81CD851B4CF78F75479343D5085BB45ADF251C64AD64A0A9FC08643AAC5E54225BB85CFDC3A95C87BC2E525205CD21A6468150641E37093D4B1096BCC2F9C145D4FE12C08C9D1BC77FEBAFC14DE0F726460F1F99830DC5685E1B8D19E97CD1E8A6CE2F88E41E936B9B15091F1628422B169C7FF8229B33FAF96695759E3514D1F4B8497D4070F0CFDF171BAA646340DFE5582A981D5508541807EE6EAAE68DC3FC65350A683E97DFDDFAA61C26B4EDD7D78A43BC2DC44C8EB90536CD0CAFBA687E876DF6DC5DAF41E361FB8C3824EAB79A0AE632CC3AA96025568AF113A302F1F68D1888CC08FE90DE79F04D6F9D0FA20F55D14907FBE79CC23105E3653A197D01F680BEBB88AD4740FC3BB44B3895581A1D347E76E4F1CCDC7FBC5B6B3A6ADC2049F7D06FB74540C10B62436ED114B849D9DDF56D521F9B7A260323FB448F2B41F01D15C1A9170F5F406A436234D2117975515912524B2E1F451EFF8F68CA2E3AFD1CAE79748975508D663250EEF5AA0464E549237DED0DF0070A99A5F7ED6B513B30170634AAC9EC1FAF403D153011AC5670B2CF3797C597B2253FA724A322CAE8C6E6ABE3F86C196BB9A95DFE10DC61443D1E0DF78BE195414F4257E33D6BDE477F335C03CDF2514B3A8E0D4EB0425D8F6C3F76391F7990A9F40742E5AC874E60F3AEA2406DBB31E75AC931596571EFAA4F71A1B96C6F86B26A09007699D56ABA03DFF90DC322287ECAD5622874EC301A4489039A1732E43C501C5E277C532EC78B59E695005508CA245019776D7B475036EF67D0A3E2E284064018AD4A39DCC19FB2BAC950C4676D4E2D1BA768B41B9EDCC74D6BD8039A7ED301D1B39DF3A6365B5452A477F6AE29BD5C174566C03C10CC52E59C23AC2193E4BF473A858CB9E778CE39A10FD14DA2603F549C05D35A4C4A3F4CE895120EBC4803BE963A1A46B4DBC75145A9468EB7362D2AB2AEF9158A1673D520AA00F6940468F55A8015C59BD1E2FC8B6D43C7622D3F3E97DE51B8DEFA8E7D5FC6E0C10F2AD34F2B2F0DF7C427A0A75495B39AAA9A0A1211B9ACB20241049877EAB72C4C435D2A3E38069CF4CE24E8212AFF5F47D60F5359A82FCCCD50F314A8002AA4DF7EDF56EE6483C5E03A2961E23918E97D0F93210176F16B64C1214AED729E5EFA9A522B980F5C6CE9DBDFBB1A0A7E11ACE1F5191FA443014D943BAC951AAB5601D571C39FCA6C2E95E01E212E95B8A474FE0753A384674BF36565EC37DD322AD8CB566B92F4317799CA0A1934EE7A262B911B26BCCA5C0A7E51B5FC9499DE5A9D78F9FDC10B8958F093FC0D39EDAC1FA88FFD2224D4FDADACBA41B7B8172C3DD8BCF05D7618733AD5EBBB19A8C4E75DC6E2BA53CB172E949ADFB7B6D33EA9F8ADC6B15BCDA157BA7F1A6D094649EE6584F089251DF04314ADA7FFF149730B35969F22A4EF50442E04E7C83F20AEEAF1CC6A8E1577FD37E01DC967A90149F18EFF5207B873C973F7525266342B95AF70ED016B310968CB0DB0491AFC7B52AC1295724011C2EB9E557E98CB4F6FF8E00F63C89842710B2ACF87426A30F6623F2CF6A489FE7C4C9B205D11B4FC307A0FD48E8B1D17A760052603DEE6E11D2D36925D7967D88CC6003D12645E5DC9CA007EABCD6502ED1FE0367F616BD7BADA1600FE4E3EE728F014390B1CA11A923C73553D26C15D51AC4A95308C5B615F04CFF50941F135822ABAB588E25550C4DB51A055D6F53DDB34EC4139C21E11CB4601CB470351E703087751F326DA2081E1D83E99A8606C1DB4BEF1CA7EE4DEBE1424F9A76467DD6A69FD31BB87E104797495AB3512B139A5157B62769F257B90DD4EAA39A9063875331DBA5EE464D411BD39571ECD440243096D96516E9AA47AD5984B1D031611B1EB132810F8FC197930D852B7A2CB4C556877263C42801C65A6C3AC98ECCC762D8E3AD7760065DE3C18A75D7F8EC344F22D991131A2C7D85DE305137DC3AEAA70E5D0984A47DC9A32CDA7956A3C0C4CB94BC6906BA220955B68ACC8178814B6A4FFFEFBB445CFCE99442EF33AB45C2201E5A203C10FAF8A658933A7730D42B02A63709A73818734F43D900291375D61DB5469A216A5CAD80C68705B06982EB6EF5A12B00E6A706E1F6B661522A7AC")
    assert.equal(cellsAndProofsHex.cells[127], "0x121273298786D77D5B2D6F97AE9B3FD69CCE49F04FEFF18E91E09498EADD585551EBE1F125DC6D98A8D44ED4622ECAC2A3934092658ADA77CB0BC26EFD6EC8A427347BCC9931DB279DDE6F5B418A4FF09D18A404044A162F3166BBD00CC54BA52EFB99FA186BDA805ADBF502F6241456A94CBE3267B4142265CD32576A95C3F527985F1C03613AC816D431445D08EB38DD9015C828885B9921C3E757A280713E71AABE25934C0EAD8EBF026FBE84D4EF420BB8EFD7ED6302E686CF26AD485D363A48B217C726DE22B7A8FAB95F682EFF1B4870E5459F779A2BEE42C5A8E132BD07D012D437D2FE63547BC3E30FFA739D76533A05CE42D41DFB868B6954CAED50361292A6E863BB2A216E92063E5AD4B36CBA9B8BAE0B3524DF7E1E26C16657A1169C1B48946CF0ECD1DAD338149896141E3B79484A7579A9AF3B24AD5FAA290C7100A7B2F31E1BDC5B7EFDF208A389C66C94B3EEC6F33F5DE56DC38BAAC2D9405C46678E03999E61521CAAD177445E9D7B30DE02C2EBF7A0A23635FE8154329C317CBC685A163ADE024375C8DCAB337B55415767DFA14A4A03CF85EF2B7174E442E45EC81BED342D36BE855BF70C65C541FAB864AA7FC333B090071EF09C37695E75CA5B497FB3E08A388E167AA285FD9B49DA8F08AC0998CBD46A4F8F12FE964ECFD75014EFD54841F064FCD40B38E2AECE53BED1F97436C0DF51140E3395732022B06495029D907C66995E10F41153F7F002AB457F4191F6B9B6109A7B0F7851C8F2957BF0C3067B81C0DBCBC91B14F6478B8FC5287043E6573B17A2391D474D30FD371F1F2B9236A53E29AF045F0B55FC9879A70DC802F2C61252E0577004204A432BDDAA17E24701FAD5DEC90CAEE82AAFD1886491F4E6CB1184D9D46EE65ACE2350284FE90C86A4BD5CB3A00293901DD996D1687BE0DED16A465B8B01FA52EC50A1BE38BC26E84C6569AAA73DB3282594A69314801F44E5F580EE531E0C20941F635CD02C551E91D7DD64C25925FCCF3F7F3A1E21D59E1DC6E61682F06E61DC0DE6779B3C439AC1ED50DD5594A8297F6BFC63098DDA17DED4FFA0B829F23555E94170BE82B9B5DA11274892AD32049274F5083A345E58AB6A4B655565F7493B189A141366D45E192E07130DD39C5E6323ED3A628A1C037492BB389DD2C21F51C1BFCF513308E65142F5FAE59001952769E8B9498037AEBA56B87148C9D45CA860D2ED8CB0F54D9DB45BE80DF3460C831E764616E330C65EF02DB25D9FC258465EDF0DFEA080E5CE00046F230503820A060F59C800AAAD5B880851D642A55A765A17E24D4658CB693425271DD1C53B1059C9233CBC4C4536AF3A9892B1D411C552A6F98338BF2F9FC0D5256587E8F59627AFD136D0A5196AFFA9F735DBB14294622139F32DD691806B9882EF6DFC53470A2D9544581F06F23CDCD781352C669F1750CC0E1108BD00B88E78F7E3FE10D7F77BB19D68505DBF9243CE18A53815EFB6B6C859402A25424C26746088C2FBDA669721B6DCCBA3FC320CAEB4C57336D897817D470C956402404271EFB2C5AC9900E035159518541C0792E694465822FED1E9253897FF0FBBEAFA199ACD6BADC5B697AEC32BE7F9CB553513E050C111B8F581B0282BEF20E78CD9EA5CB905C454D9D4C5013F50868B7689AF7299CF051CB2DADFC39F52C5E7B86C8F7BD4E1587914D7BE0E3EE93E56E8EFA0BF95BE28B5323B0F8048C9BC54E63B2D221BA9E8833926DFB4642E9048BABE3EF49DBE0450B7F11A47ABFF2B3DF06B4770D221EE838A85FE07DB40447752B7BF03C44D3BC8DCDB8F92971566FF2EA7E44B4D14401AA1110971437633F7016E21860FB44D38D9BB5213398C05758B79509CA138470DE99A8176EE0823A250BD1C9E04750F8A86B3444552B015E4CFB3F199E996A8D7163F039926F497C1681F220559E55DC585681300FD50109EA40D103B428FB5888F310B461281BF8F0F2F20E8E457260CD06CE38E5DAEB02C129FAB864AEB6A40D21A59302C761BE16C9364EAF6E26E20A5ECE31C2CE41502CECABE91414890C3E2BD2B00493E7362E437801450406B9213384A7860E385D5375E0D9973CAA75F4FE0A445FF013C56A37743D1ADAF60FB967C57209B20614B81834C5C2194862898037E30D6E3B3087089B86CBC2C31A1D0EC29D5ED09DEB8DC2133ABCA222CDD078CD749C0AB6FE38324C8E138F25F6025FB4DB0831730BA077E7D033D7565FC4A43EE088330519D4A9DCCD4FA3F448C7783B1D0F287FC18263D6B7730FF3AC8A25CAFA4E765DF0A29A2A3EBE72F1F0CCACF7C63A514EBDD23BCC6AB39CBC9B2F8F93F790FD7417B646CC8ACB1EA471F8DD84FECFD2649681F5E1A8A1477A50E5AF0407D8D8C1EE9DDE53E908CD01AE6F9F3F19A859408F777A5B138FD92C1C634FD31BF54183FC3A56C3666F50C2579BF84B07C05E0F1FBA43F7B427CF7EC7E9D0490EDBC141AD43E2ED871402D4A45913DB40F932C585F85A6800D87AE47A5ED405B8D82574F2888033670B9883A903F36B8FB3663216E5EF6C881783CEA33DFBDFCB74913599837D077511E5D6ABC2307EEDF51DE0DE72DDC54F344FB39DE7F48571001942A68F6873977AC9C4B0D77F122B9FF7C1098658DFCC80F7AFD09DBCCFA20D6DB45B58CE8D4420DE81DD8F0916AD51DB0396C84474DF15014BEB50C5465E577822DF077E512E7A19D0B7401ED842415EA2DA8A24A10BA5FFAC41244405576E6DBD8F654AD92843E5A1A2F0D006F6782AA2EBB041A5B264D29B3C0D190471F6EEA405DBA49A0DFD82953034DC65E729AA4584270F2D14808DF4D9607F32EFB81EF897CFCDDDAEEE2500B4B33509A07666ECAF03E0401712EFBCFFCE39EF52754652E36978F5EEB8308")
  })

  it('should recover cells and kzg proofs from partial cells', async () => {
    // Create a test blob with random-like data
    const blob = new Uint8Array(BYTES_PER_BLOB)
    blob[0] = 0x01
    blob[1] = 0x02
    const blobHex = bytesToHex(blob)

    // Compute cells and proofs for the original blob
    const originalCellsAndProofs = kzg.computeCellsAndKZGProofs(blobHex)

    // Verify we got the expected number of cells and proofs
    assert.equal(originalCellsAndProofs.cells.length, CELLS_PER_EXT_BLOB)
    assert.equal(originalCellsAndProofs.proofs.length, CELLS_PER_EXT_BLOB)

    // Erase half of the cells (keep every other cell, similar to C test)
    let numPartialCells = CELLS_PER_EXT_BLOB / 2
    const cellIndices: number[] = []
    const partialCells: string[] = []

    for (let i = 0; i < numPartialCells; i++) {
      const index = i * 2  // Take even-indexed cells: 0, 2, 4, 6, ...
      cellIndices.push(index)
      partialCells.push(originalCellsAndProofs.cells[index])
    }


    // Recover all cells and proofs from the partial set
    const recoveredCellsAndProofs = kzg.recoverCellsFromKZGProofs(cellIndices, partialCells, numPartialCells)

    // Verify recovered data matches original
    assert.equal(recoveredCellsAndProofs.cells.length, CELLS_PER_EXT_BLOB)
    assert.equal(recoveredCellsAndProofs.proofs.length, CELLS_PER_EXT_BLOB)

    // Verify all cells match
    for (let i = 0; i < CELLS_PER_EXT_BLOB; i++) {
      assert.equal(
        recoveredCellsAndProofs.cells[i],
        originalCellsAndProofs.cells[i],
        `Cell ${i} does not match`
      )
    }

    // Verify all proofs match
    for (let i = 0; i < CELLS_PER_EXT_BLOB; i++) {
      assert.equal(
        recoveredCellsAndProofs.proofs[i],
        originalCellsAndProofs.proofs[i],
        `Proof ${i} does not match`
      )
    }
  })

})
